{"version":3,"file":"main.1e1bec1774ccbf7522fa.bundle.js","sources":["webpack:///./src/source/tile_id.ts"],"sourcesContent":["// borrow from mapbox-gl-js\n\n// @ts-ignore\nimport * as Point from '@mapbox/point-geometry';\nimport MercatorCoordinate from '../geo/mercator_coordinate';\n// @ts-ignore\nimport * as assert from 'assert';\n\n/**\n* The maximum value of a coordinate in the internal tile coordinate system. Coordinates of\n* all source features normalized to this extent upon load.\n*\n* The value is a consequence of the following:\n*\n* * Vertex buffer store positions as signed 16 bit integers.\n* * One bit is lost for signedness to support tile buffers.\n* * One bit is lost because the line vertex buffer used to pack 1 bit of other data into the int.\n*   This is no longer the case but we're reserving this bit anyway.\n* * One bit is lost to support features extending past the extent on the right edge of the tile.\n* * This leaves us with 2^13 = 8192\n*\n* @private\n* @readonly\n*/\nexport const EXTENT = 8192;\n\nexport class CanonicalTileID {\n  z: number;\n  x: number;\n  y: number;\n  key: number;\n\n  constructor(z: number, x: number, y: number) {\n    assert(z >= 0 && z <= 25);\n    assert(x >= 0 && x < Math.pow(2, z));\n    assert(y >= 0 && y < Math.pow(2, z));\n    this.z = z;\n    this.x = x;\n    this.y = y;\n    this.key = calculateKey(0, z, x, y);\n  }\n\n  equals(id: CanonicalTileID) {\n    return this.z === id.z && this.x === id.x && this.y === id.y;\n  }\n\n  getTilePoint(coord: MercatorCoordinate) {\n    const tilesAtZoom = Math.pow(2, this.z);\n    return new Point(\n      (coord.x * tilesAtZoom - this.x) * EXTENT,\n      (coord.y * tilesAtZoom - this.y) * EXTENT);\n  }\n}\n\nexport class UnwrappedTileID {\n  wrap: number;\n  canonical: CanonicalTileID;\n  key: number;\n\n  constructor(wrap: number, canonical: CanonicalTileID) {\n    this.wrap = wrap;\n    this.canonical = canonical;\n    this.key = calculateKey(wrap, canonical.z, canonical.x, canonical.y);\n  }\n}\n\nexport class OverscaledTileID {\n  overscaledZ: number;\n  wrap: number;\n  canonical: CanonicalTileID;\n  key: number;\n  posMatrix: Float32Array;\n\n  constructor(overscaledZ: number, wrap: number, z: number, x: number, y: number) {\n    assert(overscaledZ >= z);\n    this.overscaledZ = overscaledZ;\n    this.wrap = wrap;\n    this.canonical = new CanonicalTileID(z, +x, +y);\n    this.key = calculateKey(wrap, overscaledZ, x, y);\n  }\n\n  equals(id: OverscaledTileID) {\n    return this.overscaledZ === id.overscaledZ && this.wrap === id.wrap && this.canonical.equals(id.canonical);\n  }\n\n  scaledTo(targetZ: number) {\n    assert(targetZ <= this.overscaledZ);\n    const zDifference = this.canonical.z - targetZ;\n    if (targetZ > this.canonical.z) {\n      return new OverscaledTileID(targetZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);\n    } else {\n      return new OverscaledTileID(targetZ, this.wrap, targetZ, this.canonical.x >> zDifference, this.canonical.y >> zDifference);\n    }\n  }\n\n  isChildOf(parent: OverscaledTileID) {\n    if (parent.wrap !== this.wrap) {\n      // We can't be a child if we're in a different world copy\n      return false;\n    }\n    const zDifference = this.canonical.z - parent.canonical.z;\n    // We're first testing for z == 0, to avoid a 32 bit shift, which is undefined.\n    return parent.overscaledZ === 0 || (\n      parent.overscaledZ < this.overscaledZ &&\n      parent.canonical.x === (this.canonical.x >> zDifference) &&\n      parent.canonical.y === (this.canonical.y >> zDifference));\n  }\n\n  children(sourceMaxZoom: number) {\n    if (this.overscaledZ >= sourceMaxZoom) {\n      // return a single tile coord representing a an overscaled tile\n      return [new OverscaledTileID(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n    }\n\n    const z = this.canonical.z + 1;\n    const x = this.canonical.x * 2;\n    const y = this.canonical.y * 2;\n    return [\n      new OverscaledTileID(z, this.wrap, z, x, y),\n      new OverscaledTileID(z, this.wrap, z, x + 1, y),\n      new OverscaledTileID(z, this.wrap, z, x, y + 1),\n      new OverscaledTileID(z, this.wrap, z, x + 1, y + 1)\n    ];\n  }\n\n  isLessThan(rhs: OverscaledTileID) {\n    if (this.wrap < rhs.wrap) return true;\n    if (this.wrap > rhs.wrap) return false;\n\n    if (this.overscaledZ < rhs.overscaledZ) return true;\n    if (this.overscaledZ > rhs.overscaledZ) return false;\n\n    if (this.canonical.x < rhs.canonical.x) return true;\n    if (this.canonical.x > rhs.canonical.x) return false;\n\n    if (this.canonical.y < rhs.canonical.y) return true;\n    return false;\n  }\n\n  wrapped() {\n    return new OverscaledTileID(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n  }\n\n  unwrapTo(wrap: number) {\n    return new OverscaledTileID(this.overscaledZ, wrap, this.canonical.z, this.canonical.x, this.canonical.y);\n  }\n\n  overscaleFactor() {\n    return Math.pow(2, this.overscaledZ - this.canonical.z);\n  }\n\n  toUnwrapped() {\n    return new UnwrappedTileID(this.wrap, this.canonical);\n  }\n\n  toString() {\n    return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n  }\n\n  getTilePoint(coord: MercatorCoordinate) {\n    return this.canonical.getTilePoint(new MercatorCoordinate(coord.x - this.wrap, coord.y));\n  }\n}\n\nfunction calculateKey(wrap: number, z: number, x: number, y: number) {\n  wrap *= 2;\n  if (wrap < 0) wrap = wrap * -1 - 1;\n  const dim = 1 << z;\n  return ((dim * dim * wrap + dim * y + x) * 32) + z;\n}\n"],"mappings":"AAGA","sourceRoot":""}