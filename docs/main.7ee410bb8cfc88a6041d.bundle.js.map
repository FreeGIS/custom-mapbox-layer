{"version":3,"file":"main.7ee410bb8cfc88a6041d.bundle.js","sources":["webpack:///./src/utils/tile-cover.ts"],"sourcesContent":["import MercatorCoordinate from '../geo/mercator_coordinate';\n// @ts-ignore\nimport * as Point from '@mapbox/point-geometry';\nimport { OverscaledTileID } from '../source/tile_id';\n\ninterface Edge {\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n  dx: number;\n  dy: number;\n}\n\ninterface ScanLineFunction {\n  (x0: number, x1: number, y: number): void;\n}\n\nexport default function tileCover(z: number, bounds: [MercatorCoordinate, MercatorCoordinate, MercatorCoordinate, MercatorCoordinate],\n  actualZ: number, renderWorldCopies: boolean | void): Array<OverscaledTileID> {\n  if (renderWorldCopies === undefined) {\n    renderWorldCopies = true;\n  }\n  const tiles = 1 << z;\n  const t: {[key: string]: OverscaledTileID} = {};\n\n  function scanLine(x0: number, x1: number, y: number) {\n    let x, w, wx, coord;\n    if (y >= 0 && y <= tiles) {\n      for (x = x0; x < x1; x++) {\n        w = Math.floor(x / tiles);\n        wx = (x % tiles + tiles) % tiles;\n        if (w === 0 || renderWorldCopies === true) {\n          coord = new OverscaledTileID(actualZ, w, z, wx, y);\n          t[coord.key] = coord;\n        }\n      }\n    }\n  }\n\n  const zoomedBounds = bounds.map((coord) => new Point(coord.x, coord.y)._mult(tiles));\n\n  // Divide the screen up in two triangles and scan each of them:\n  // +---/\n  // | / |\n  // /---+\n  scanTriangle(zoomedBounds[0], zoomedBounds[1], zoomedBounds[2], 0, tiles, scanLine);\n  scanTriangle(zoomedBounds[2], zoomedBounds[3], zoomedBounds[0], 0, tiles, scanLine);\n\n  return Object.keys(t).map((id) => {\n    return t[id];\n  });\n}\n\n\n// Taken from polymaps src/Layer.js\n// https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383\n\nfunction edge(a: Point, b: Point): Edge {\n  if (a.y > b.y) { const t = a; a = b; b = t; }\n  return {\n    x0: a.x,\n    y0: a.y,\n    x1: b.x,\n    y1: b.y,\n    dx: b.x - a.x,\n    dy: b.y - a.y\n  };\n}\n\nfunction scanSpans(e0: Edge, e1: Edge, ymin: number, ymax: number, scanLine: ScanLineFunction) {\n  const y0 = Math.max(ymin, Math.floor(e1.y0));\n  const y1 = Math.min(ymax, Math.ceil(e1.y1));\n\n  // sort edges by x-coordinate\n  if ((e0.x0 === e1.x0 && e0.y0 === e1.y0) ?\n    (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :\n    (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {\n    const t = e0; e0 = e1; e1 = t;\n  }\n\n  // scan lines!\n  const m0 = e0.dx / e0.dy;\n  const m1 = e1.dx / e1.dy;\n  const d0 = e0.dx > 0 ? 1 : 0; // use y + 1 to compute x0\n  const d1 = e1.dx < 0 ? 1 : 0; // use y + 1 to compute x1\n  for (let y = y0; y < y1; y++) {\n    const x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;\n    const x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;\n    scanLine(Math.floor(x1), Math.ceil(x0), y);\n  }\n}\n\nfunction scanTriangle(a: Point, b: Point, c: Point, ymin: number, ymax: number, scanLine: ScanLineFunction) {\n  let ab = edge(a, b),\n    bc = edge(b, c),\n    ca = edge(c, a);\n\n  let t;\n\n  // sort edges by y-length\n  if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }\n  if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }\n  if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }\n\n  // scan span! scan span!\n  if (ab.dy) scanSpans(ca, ab, ymin, ymax, scanLine);\n  if (bc.dy) scanSpans(ca, bc, ymin, ymax, scanLine);\n}\n\n"],"mappings":"AAEA","sourceRoot":""}